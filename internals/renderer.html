<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Amethyst Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./intro.html"><strong>1.</strong> Introduction</a></li><li><a href="./getting_started.html"><strong>2.</strong> Getting Started</a></li><li><ul class="section"><li><a href="./getting_started/installation.html"><strong>2.1.</strong> Installation</a></li></ul></li><li><a href="./internals.html"><strong>3.</strong> Internals</a></li><li><ul class="section"><li><a href="./internals/renderer.html" class="active"><strong>3.1.</strong> Renderer</a></li><li><ul class="section"><li><a href="./internals/renderer/frontend.html"><strong>3.1.1.</strong> Frontend</a></li><li><a href="./internals/renderer/ir.html"><strong>3.1.2.</strong> IR</a></li><li><a href="./internals/renderer/backend.html"><strong>3.1.3.</strong> Backend</a></li></ul></li><li><a href="./internals/scripting.html"><strong>3.2.</strong> Scripting</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Amethyst Documentation</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Renderer Design</h1>
<p>Central to a visually impressive game is a powerful renderer. The document below describes the design decisions behind the rendering engine developed for Amethyst.</p>
<h2>Goals</h2>
<ul>
<li>Develop a portable real-time 3D renderer with support for multiple backends.
<ul>
<li>Priority: Vulkan 1.0+, OpenGL 4.3+</li>
<li>Others are nice to have.</li>
</ul>
</li>
<li>Design a simple and high-level submission format. Clients should never directly alter low-level GPU state in code.
<ul>
<li>Frames, objects, and lights.</li>
</ul>
</li>
<li>Embrace data-driven design from the start.
<ul>
<li>No rendering approach built in, users load it in as a data structure.</li>
<li>Objects, lights, and render paths should be easy to serialize and de-serialize.</li>
</ul>
</li>
<li>Internal abstractions should take inspiration from modern graphics API design patterns. Next-gen ready, backwards compatible with legacy stateful APIs like OpenGL.
<ul>
<li>Static state objects created once on startup and cached (i.e. pipelines).</li>
<li>Dynamic state objects updated per-frame (i.e. blend, depth-stencil, rasterizer, viewport).</li>
<li><a href="http://blog.molecular-matters.com/2014/11/06/stateless-layered-multi-threaded-rendering-part-1/">Stateless draw calls</a>.</li>
<li>Multithreading used judiciously throughout to maximize performance.</li>
</ul>
</li>
<li>Make this renderer usable outside of the Amethyst engine itself.</li>
</ul>
<h2>Non-Goals</h2>
<ul>
<li>Provide a game loop or event/message pump.
<ul>
<li>Argument: Should be responsibility of the game engine or client application. Renderer code should be reusable and easy to integrate into a variety of third-party application frameworks.</li>
</ul>
</li>
<li>Implement a scene graph or &quot;game world&quot; data structure.
<ul>
<li>Argument: Separation of concerns. The renderer should only know how to draw a set of objects on screen, and it should not force a particular scene model on its users. Whether one prefers use a traditional class hierarchy over an entity-component-system model, or vice versa, should not matter.</li>
</ul>
</li>
<li>Implement a default spatial data structure, e.g. an octree or BSP.
<ul>
<li>Argument: Scene culling methods all have different performance requirements. The user should decide what spatial data structure is most suitable for their needs.</li>
</ul>
</li>
<li>Implement or provide a default serialization file format parser, e.g. XML, JSON, or YAML.
<ul>
<li>Argument: The user can choose to represent their render path in a manner most suitable to their application, whether that be in an external file or hard-coded in Rust.</li>
</ul>
</li>
</ul>
<h2>High-Level Design</h2>
<p>The final design loosely resembles the approach used by <a href="http://bitsquid.blogspot.com/2009/10/parallel-rendering.html">Bitsquid</a> (now Autodesk Stingray), the <a href="http://www.gdcvault.com/play/1020706/Nitrous-Mantle-Combining-Efficient-Engine">Oxide Engine</a>, and <a href="http://fabiensanglard.net/doom3/renderer.php">id Tech 4</a>. There are three main parts:</p>
<ol>
<li>Frontend
<ul>
<li>Loads a <code>RenderPath</code> structure upon initialization. Uses it at runtime to convert a given <code>Frame</code> into an intermediate representation (IR).</li>
<li>Sorts the IR to minimize redundant state changes.</li>
</ul>
</li>
<li>Intermediate Representation
<ul>
<li>A set of data structures that represent the high-level actions that the GPU must take in order to render a single <code>Frame</code>.</li>
<li>Essentially stateless draw calls. Similar to command buffers in Vulkan, but API-agnostic.</li>
</ul>
</li>
<li>Backend
<ul>
<li>Translates the IR received from the frontend into low-level API calls.</li>
<li>One backend for each target API.</li>
<li>Backends are selected by users at compile time. For the sake of runtime overhead and stability, dynamic switching of backends is not supported.</li>
</ul>
</li>
</ol>
<p><img src="./internals/overall.png" alt="Overall" /></p>
<h2>Example Usage</h2>
<pre><code class="language-rust">//! This is a dummy program making direct use of the renderer.

extern crate amethyst;
extern crate amethyst_opengl;

use amethyst::renderer::*;
use amethyst_opengl::BackendGl;

fn main() {
    // Describe our render path, e.g. forward, deferred, depth pre-pass, etc.
    let mut example = RenderPath { ... };

    // Initialize the renderer with our choice of backend.
    let mut frontend = Frontend::new(BackendGl);
    frontend.use_path(example);

    loop {
        // Collect all data needed for rendering.
        let mut frame = Frame { ... };

        // Draw!
        frontend.draw(frame);
    }
}
</code></pre>
<p>See the next three sections to learn how the frontend, IR, and backend all work in more detail.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="./internals.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="./internals/renderer/frontend.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./internals.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./internals/renderer/frontend.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
